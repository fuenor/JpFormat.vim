*jpformat.jax*	For Vim バージョン 7.2	Last change: 2013 August 2
==============================================================================
       Description: JpFormat.vim 日本語整形プラグイン
            Author: fuenor <fuenor@gmail.com>
            Web(Japanese):
            https://github.com/fuenor/JpFormat.vim
==============================================================================

CONTENTS					*jpformat_contents*
1. Intro                                        |jpformat_intro|
2. インストール                                 |jpformat_install|
  2.1 gqコマンドとして使用する場合の設定        |jpformat_install_gq|
3. コマンド一覧                                 |jpformat_command|
4. 手動整形                                     |jpformat_format|
5. 自動整形                                     |jpformat_auto_format|
6. 整形行の連結                                 |jpformat_join|
7. 原稿枚数を計算する。                         |jpformat_count|
8. オプション                                   |jpformat_options|
9. 整形の内部処理                               |jpformat_formatexpr|
10. 外部ビューアを起動する                      |jpformat_viewer|
11. Tips                                        |jpformat_tips|
12. オプションリスト                            |jpformat_option_list|

==============================================================================
1. Intro						*jpformat_intro*

JpFormat.vimはVimで日本語の禁則処理に対応したフォーマット整形プラグインです。

Vim単体でも|wrapmargin|や|textwidth|などを使用して整形が行えますが日本語の禁則
処理は考慮されていません。
日本語対応のgqコマンドが必要な場合はJpFormat.vimをformatexprに登録して使用可能
です。

長文の日本語文書をまとめて整形したい場合|gq|コマンドは空行のみを段落の区切りと
みなして連結して改行を埋め込んでしまうので本来の構造が失われます。
JpFormat.vimは行頭の全角スペースや「などを段落の区切りとして扱うことも出来るの
で100gqのようにまとめて整形も簡単に行えます。

JpFormat.vimの大きな特徴は「疑似ソフトラップ」が行えることです。
「擬似ソフトラップ」は入力を行いながら編集中の日本語文書を自動整形して原稿の整
形結果を常に確認しながら編集するためのものです。
Vimが実際に折り返しを行う際には改行を埋め込みますが、表示上の改行をマーカーで
管理するので原稿形式を何回変更しても元の構造は保持され、何度整形しても元の非整
形状態に戻せるために安心して書きかけの原稿に整形を掛ける事が出来ます。
このため未完成原稿でも整形結果を確認しながら、挿入モードで入力する度に自動整形
するような使い方もストレス無く実行出来るようになります。
「擬似ソフトラップ」モードでは未完成原稿をマーカーを使用して整形し、最終原稿で
は全文連結コマンドかマーカー削除を実行するというのが主な使い方になります。

商業原稿の作成や青空文庫の小説などの長文を読むような場合は折り返し整形してやる
と読みやすさが結構違ってきます。

このファイルもJpFormat.vimを使用して整形されています。

==============================================================================
2. インストール						*jpformat_install*

GitHub(https://github.com/fuenor/JpFormat.vim) からダウンロードしたzipファイル
を解凍してできたディレクトリにランタイムパスを通します。
たとえばGitHubからダウンロードしたzipファイルを解凍して出来たディレクトリが
c:\temp\JpFormat.vim-masterであった場合は.vimrcで次のようにパスを通します。
>
  set runtimepath+=c:/temp/JpFormat.vim-master

(注意)
linebreakオプションを.vimrc等で有効化している場合は、ファイル読込時や編集時に
見た目上の整形が行なわれますが、これはJpFormat.vimの機能とバッティングします。
JpFormat.vimを使用したいファイル(ファイルタイプ)に対しては、autocmd等で
linebreakを無効化することをおすすめします。

2.1 gqコマンドとして使用する場合の設定 			*jpformat_install_gq*

JpFormat.vimにはgqコマンドとして使用可能な、日本語禁則処理対応の整形プラグイン
jpfmt.vimとjpvim.vimが同梱されています。
jpfmt.vimをgqコマンドとして使用する場合はformatexprを設定してください。 >

  " 日本語対応gqコマンドとして使用する
  set formatexpr=jpfmt#formatexpr()

単にgqコマンドとしてのみ使用する場合はこれだけで動作しますので、日本語の長い行
で gqq などとして実行してみてください。

jpvim.vimはjpfmt.vimと違い、設定にかかわらず「ぶら下げ」を行いません。
gqコマンドとしてはjpvim.vimのほうが違和感がないかもしれません。
>
  " ぶら下げを行わない日本語対応gqコマンドとして使用する
  set formatexpr=jpvim#formatexpr()

またjpvimの時だけ拗音と促音(っァなど)を通常文字として扱うことができます。
ドキュメントなどでなるべく追い出し処理を行いたくない時に使用してください。
>
  " jpvim.vimだけ拗音と促音を通常文字扱い
  let g:jpvim_remove_youon = 1

------------------------------------------------------------------------------
jpfmt.vim、jpvim.vimの共通設定になりますが日本語文書への対応として、行頭が 　
(全角スペース)か「 で始まった場合は段落開始とみなして処理を行います。
このためgq8jのように複数行をまとめて処理しても　(全角スペース)か「で始まる行
は連結されません。
ユーザー指定の段落開始行は jpfmt_paragraph_regexp の正規表現で指定可能です。
>
  " 段落開始とみなす正規表現
  let jpfmt_paragraph_regexp = '^[　「]'

------------------------------------------------------------------------------
現在のカーソル行から次の段落行までを整形させることもできます。
gqpなどにマップして使用すると便利かもしれません。
>
  nnoremap <silent> gqp :<C-u>call jpfmt#gqp()<CR>
  nnoremap <silent> gqp :<C-u>call jpvim#gqp()<CR>

------------------------------------------------------------------------------
次章からは連結マーカーを利用した「擬似ソフトラップ」を行うためのコマンド群につ
いての解説になります。
単にgqコマンドとしてしか使用しないけれども、禁則処理対象文字を変更したいなどの
場合は|jpformat_tips|, |jpformat_option_list|を参照してみてください。
なおJpFormat.vimをgqコマンドとしては使用しないで「擬似ソフトラップ」としてのみ
使用する場合は|formatexpr|の設定は不要です。

==============================================================================
3. コマンド一覧						*jpformat_command*

いずれのコマンドもビジュアルモードやカウントで範囲を指定できます。

JpFormat           指定範囲を整形する。
                   !を付けると整形対象外の行でも強制整形する。
JpFormatAll        指定範囲(デフォルトは全て)を整形する。
                   !を付けると連結マーカーを使用しない。
JpFormatP          指定範囲を含むパラグラフを整形する。
                   !を付けると整形対象外の行でも強制整形する。

JpJoin             指定範囲を含むパラグラフを連結する。
JpJoinAll          指定範囲(デフォルトは全て)を含むパラグラフを連結する。
                   !をつけると連結マーカーを使用していないものとして連結する。
JpYank             現在行を含むパラグラフをヤンクする。

JpFormatToggle     自動整形の有効/無効を切り替える。
                   :JpFormatToggleのようにカウント指定すると折り返し文字数が
                   バッファのみ指定カウントに変更される。
                   えば gC など適当なキーにマップして gC や 30gCとして使う。
JpFormatGqToggle   整形に gqコマンドを呼び出して行うかどうかを切り替える。
JpCountPages       指定範囲(デフォルトは全て)のルビ等を削除した原稿枚数を計
                   算する。
JpExtViewer        現バッファの内容をコピーして、連結、エンコードの変換を行
                   外部ビューアを起動する。
                   !を付けると現在開いているファイルそのものを渡して起動する。

・ここで言う連結とはJpFormat.vimで整形された分割部分を元に戻す事です。
・整形されていない行では連結を実行しても何もしないので、単純な連結には通常の行
と同じく J を使用して下さい。
・パラグラフとは物理的な改行で区切られた1行を整形分割した全ての行のまとまりで
す。

==============================================================================
4. 手動整形						*jpformat_format*

:JpFormatAll を実行すると指定範囲(デフォルトは全て)を規定の形式に整形します。
何か一行が長い日本語文書を用意して実行してみて下さい。
小説が一番わかりやすいので、適当なファイルがなければ青空文庫などから持ってくる
のも良いかもしれません。 >
  :JpFormatAll

整形結果を見るとわかりますが、長い文は「タブ記号+改行」で分割して禁則処理を行
います。
このタブ記号は「連結マーカー」で、改行が実際の改行なのか、整形によって分割され
た改行なのかを示しています。
:JpJoinAll を実行すると分割行は連結されます。

NOTE:デフォルトの「連結マーカー」にはタブ記号が使われていますが、何も設定しな
いと見えません。
タブ記号は .vimrc に以下の設定を行うと|SpecialKey|で強調表示されます。 >
  set list
  set listchars=tab:^\ ,trail:~

ノーマルモードで現在行を手動整形したい場合はJpFormatコマンドを使用するか、キー
にマッピングして使用して下さい。JpFormatやJpFormatAll はカウント指定やビジュア
ルモードの指定も有効です。

------------------------------------------------------------------------------
.vimrc でのキーマップ設定例

JpFormatの性質上よく使う整形コマンドはキーにマップして使うほうが便利です。
実際には JpFormat と JpFormatToggleをマップすれば十分使えます。
>
  " 日本語の行の連結時には空白を入力しない。
  set formatoptions+=mM

  " 現在行を整形
  nnoremap <silent> gl :JpFormat<CR>
  vnoremap <silent> gl :JpFormat<CR>

  " 自動整形のON/OFF切替
  " 30gC の様にカウント指定すると、
  " 現バッファのみ折り返し文字数を指定されたカウントに変更
  nnoremap <silent> gC :JpFormatToggle<CR>

この例だと gl で整形することになります。
コマンドは 3gl の用にカウント指定や、ビジュアルモードで範囲を指定可能です。
単純な連結は通常通り J で、分割された行(パラグラフ)は gJ でまとめて連結可能で
す。

個人的には JpFormatAll や JpCountPagesもよく使うのでキーマップしています。
>
  nnoremap <silent> g,rJ :JpFormatAll<CR>
  nnoremap <silent> g,rc :JpCountPages!<CR>

------------------------------------------------------------------------------
非整形状態に戻すには :JpJoinAll を実行しますが、整形状態を保ったまま連結マー
カーを削除したい場合は :JpFormatAll! を実行して下さい。
JpFormatAll!で「連結マーカー」を削除する場合は不可逆過程ですので、必ずバックア
ップを取ってから実行して下さい。

formatoption は好みですが、J コマンドでの日本語を含む行の連結は空白を追加しな
い方がよいかと思います。

==============================================================================
5. 自動整形						*jpformat_auto_format*

基本的には JpFormat を好みのキーにマッピングして、必要に応じて整形、連結を行い
ます。
ただ一々手動で整形するのも面倒なので、自動整形させる事が可能です。

何か一行が長い文を含む日本語文書のファイルを用意して :JpFormatAll や :JpFormat
コマンドで整形するか、キーマップした整形コマンドを実行して下さい。
長い行は整形され、そのあと挿入モードで適当に入力すると自動で整形が行われます。

* 自動整形の種類

自動整形は挿入モードで一文字入力する度に自動整形をするか、挿入モード終了時に自
動整形するかを選択できます。 >
  " 挿入モードでキー入力する度に自動整形を行う/行わない
  let JpFormatCursorMovedI = 1

JpFormatCursorMovedI = 1 に設定すると挿入モードで一文字入力する度に自動整形さ
れ JpFormatCursorMovedI = 0 なら挿入モードを抜ける時にまとめて整形を行います。
編集時の見やすさなども含めて好みの方を使用して下さい。

自動整形が有効になるのは以下の場合です。

    * バッファ内でJpFormat等のコマンドを実行する
    * バッファ内でJpFormatToggleを実行して切替

また以下を .vimrcに追加すると、次回からはtxtファイルに「連結マーカー+改行」が
あれば自動整形モードが最初から有効になります。 >

  " txtファイルで「連結マーカー+改行」が有ったら自動整形を有効にする
  au BufRead *.txt JpSetAutoFormat

「連結マーカー+改行」の有無にかかわらず自動整形を有効にしたい場合は、!を付加し
ます。 >

  " txtファイルでは常に自動整形を有効にする
  au BufRead *.txt JpSetAutoFormat!

なお状態はバッファローカルなオプション b:jpformat で制御されているため
let b:jpformat = 1 を設定することでも、そのバッファのみ自動整形をオンにするこ
とが可能です。

コマンド実行後も常に自動整形をオフにしたい場合は以下のように設定します。
>
  " 整形コマンドを使用したら自動整形もON
  let JpAutoFormat = 0

==============================================================================
6. 整形行の連結						*jpformat_join*

現在行の連結には J コマンドか、キーマップしたJpJoinを使用します。
全文を非整形状態に戻したいだけの場合は JpJoinAll を実行します。 >
  :JpJoinAll

整形状態を保ったまま「連結マーカー」を削除したい場合、「連結マーカー」を使用し
ないで全文整形(コマンドに ! を付加して実行)します。 >
  :JpFormatAll!

「連結マーカー」はただの文字(タブ記号)なので通常の削除や置換でも削除可能です。 >
  :%s/\t$//g

再連結は JpJoinAll! です。

「連結マーカー」が削除されていても再連結は可能ですが、整形前の文書と異なる場合
があります。
これは整形表示行の境界や「ぶら下げ」処理された次の行が、真の改行か整形されたこ
とによる改行かの区別がつかない場合があるためです。
「連結マーカー」の削除は不可逆過程ですので最終処理としてバックアップを取った上
で実行して下さい。

「連結マーカー」を使用しない連結の行判定には以下のオプションが使用されます。 >
  " 連結マーカー非使用時のTOLキャラクター
  let JpJoinTOL = '[\s　「・＊]'
  " 連結マーカー非使用時のEOLキャラクター
  let JpJoinEOL = '[。」！？］]'

==============================================================================
7. 原稿枚数を計算する。					 *jpformat_count*

:JpCountPages を実行すると現在の原稿枚数を計算できます。 >
 :JpCountPages

計算する際にはルビや制御用スクリプトを削除した、実際の原稿枚数を計算します。
>
  " 原稿用紙換算計算時に削除するルビ等の正規表現
  let JpCountDeleteReg = '\[[^]]\+\]\|<[^>]\+>\|《[^》]\+》\|［[^］]\+］\|｜'

現在の縦文字数や行数と異なるページ数をカウントしたい場合は、JpCountPages実行時
に文字数と行数を指定します。
>
  JpCountPages [折り返し文字数] [行数] {ぶら下がり文字数}
<
  行数、ぶら下がり文字数は省略可能です。

現在40×17フォーマットで整形していて、20×20フォーマットのページ数を知りたい場
合は次のように実行します。 >
  :JpCountPages 20 20

------------------------------------------------------------------------------
* 原稿枚数計算のEasyモード

原稿枚数計算では内部的に全文整形を行っているので、長い文書ではそれなりに時間が
かかります。
概算でかまわないような場合、整形済みの文書では簡易的に行数から原稿枚数計算を行
う事が出来ます。
>
  :JpCountPages!

Easyモードではルビ等も通常の文字と見なされますが、ルビ等の制御記号を使用してい
なければ正確な枚数表示がなされます。 >
文書内に連結マーカーが存在しない場合は通常通り JpCountPagesが実行されます。

JpCountPagesは適当なキーにマップして使用すると良いかもしれません。
>
  " 現在の原稿枚数計算(簡易)
  noremap <silent> gc :JpCountPages!<CR>

------------------------------------------------------------------------------
* リアルタイムに文字数を確認する

JpFormat.vimとは直接関係ありませんが、ステータス行に現バッファの文字数を表示す
ることも出来ます。
https://github.com/fuenor/vim-wordcount/blob/master/wordcount.vim

==============================================================================
8. オプション						*jpformat_options*

* 原稿形式(折り返し文字数等)

原稿形式は以下のオプションで設定します。 >

 " 原稿文字数(全角の折り返し文字数)
 let JpCountChars = 40
 " 原稿行数
 let JpCountLines = 17
 " 禁則処理の最大ぶら下がり字数(-1なら全てぶら下げ)
 let JpCountOverChars = 1

このオプション値はデフォルト指定で、実際に整形する時は b: のついたバッファロー
カルな変数が使用されます。

特定のバッファでデフォルト以外の値を使用したい場合は b: を付けて指定します。
たとえば一行あたりの文字数を変更したい場合は、コマンドモードから次のように指定
します。 >
  :let b:JpCountChars=30

また通常 :JpFormatToggleは自動整形のON/OFFを切り替えるために使用しますが、カウ
ント指定した場合はON/OFF切り替えではなく指定カウントをそのバッファの折り返し文
字数に設定します。
>
  :30JpFormatToggle
<
  これは :let b:JpCountChars=30と同等の結果になります。
  JpFormatToggleをキーマップしておいて使用すると便利かもしれません。

特定拡張子や特定ファイルで個別の文字数で折り返したい時は.vimrcで次のように設定します。 >
  " 拡張子txtの折り返し文字数は20文字
  au BufRead,BufNewFile *.txt   let b:JpCountChars=20
  " abc.txtの折り返し文字数は42文字
  au BufRead,BufNewFile abc.txt let b:JpCountChars=42
  " ファイルタイプqfix_memoの折り返し文字数は30文字
  au FileType qfix_memo         let b:JpCountChars=30

textwidthから折り返し文字数を設定する事も出来ます。 >
  "折り返し文字数は textwidthから設定する
  let JpCountChars_Use_textwidth = 1
<
  1に設定すると b:JpCountCharsは textwidthの値を使用します。
  textwidthが奇数の場合は全角文字が半角一文字分オーバーすることがありますが、
  これを許容するかどうか設定可能です。
>
  " 半角一文字分オーバーしても折り返し処理をする/しない
  let JpFormatHankakuOver = 0

現在の縦文字数や行数と異なる形式へ一時的に整形したい場合は、実行時に指定します。
  JpFormatAll [折り返し文字数] [行数] {ぶら下がり文字数}

行数やぶら下がり文字数は省略可能です。
現在40×17フォーマットで整形していて、20×20フォーマットに変更したい場合は次の
ように実行します。 >
  :JpFormatAll 20 20

------------------------------------------------------------------------------
* 特定の行を整形対象外にする

特定の行を整形対象外にする事も出来ます。
整形対象外にする条件は JpFormatExcludeで指定します。
このオプションはデフォルト指定で、実際に整形する時はバッファローカルな変数
b:JpFormatExclude が使用されます。
デフォルトでは空文字列(実際には'^$'に変換されます)が指定されているので全ての行
が対象です。

以下のように設定すると半角文字だけの行なら整形しません。 >
  " 整形対象外の正規表現(空文字 か'^$' を指定すると全ての行が整形対象)
  " 半角だけの行は整形しない
  let JpFormatExclude = '^[^[\x00-\xff]]\+$'

行頭が日本語以外は対象外にしたい場合は以下のようにします。 >
  " 日本語以外で始まった場合は整形しない
  let JpFormatExclude = '^[\x00-\xff]'

gqなどの整形コマンドや他の整形プラグインを併用したい場合、使用したい行を対象外
に設定して使用してください。

特定のファイルでだけ整形対象外の正規表現を変更することも出来ます。
b:を付けて .vimrcで指定して下さい。 >
  au BufRead,BufNewFile *.howm let b:JpFormatExclude = '^[-+.*=|>";/[[:space:]]'

==============================================================================
9. 整形の内部処理					*jpformat_formatexpr*

JpFormat.vimの「擬似ソフトラップ」における整形処理はJpFormat.vimの「内部整形」
と|gq|を内部的に呼び出す「gq整形」との2種類から選択可能です。

「内部整形」は非常に高速ですがソースコードを認識してのコメント処理は行わないな
ど、英数字の処理はVimデフォルトの|gq|コマンドとは異なる処理になることがありま
す。
実際問題として「擬似ソフトラップ」は日本語文書専用という位置づけで使用すること
がほとんでしょうから問題になることは殆ど無いはずです。

ただしJpFormat.vimの整形処理が気に入らない場合は内部的に|gq|コマンドを呼び出し
て整形させることも可能です。
この場合の日本語の禁則処理等は|gq|コマンド(|formatexpr|)に依存することになりま
す。 >
速度面では「gq整形」の方が遅くなります。

NOTE:
内部整形とgq整形は :JpFormatGqToggle でも切り替える事が出来ます。

------------------------------------------------------------------------------
* 内部整形(JpFormat.vim)

formatexprは使用せずにビルトインの禁則処理関数で整形していて高速に動作します。
>
  " 内部整形で整形を行う(デフォルト)
  let JpFormatGqMode = 0

------------------------------------------------------------------------------
* gq整形

Vimの|formatexpr|に登録されているgqコマンドを内部的に呼び出して整形する場合は
次のように設定します。 >
  " gqを使用して整形を行う
  let JpFormatGqMode = 1

この場合の日本語禁則処理等は|gq|コマンド(|formatexpr|)に依存することになりま
す。

「擬似ソフトラップ」で使用するコマンドを|gq|とは別に指定することも可能です。
 >
  " gqを使用して整形を行う
  let JpFormatGqMode = 1
  " 「擬似ソフトラップ」で使用する整形コマンド
  let JpFormat_formatexpr = 'jpfmt#formatexpr()'

たとえば|gq|では「ぶら下げ処理」を行いたくないのでjpvim#formatexpr()を使用し
て、「擬似ソフトラップ」のgq整形では「ぶら下げ処理」をするjpfmt#formatexpr()を
使用するなどのように使います。
JpFormat_formatexprは|formatexpr|に登録可能な式であればJpFormat.vimに限らずな
んでも使用可能です。

==============================================================================
10. 外部ビューアを起動する				 *jpformat_viewer*

JpFormat.vimで整形しながら編集しているファイルには連結マーカーや改行が埋め込ま
れています。
Vimは縦書き表示できないので青空文庫ビューアを起動して縦書き表示で確認するよう
な場合は、ルビや制御用スクリプトなどで埋め込まれているマーカーや改行が問題にな
ることがあります。
この問題に対応して JpFormat.vimから外部ビューアで開く際に分割行の連結とファイ
ルエンコーディングの変更を行ってから外部ビューアへ渡す事が出来ます。

設定
  必要ならファイルを開くための外部ビューアをインストールしてください。
  例: ArisuViewer, smoopy

* Windows

  ArisuViewer >
  " ArisuViewerで開く
  let ExtViewer_txt = '!start "'.'C:/viewer/ArisuViewer.exe'.'"'.' -l %l "%f"'
  "cp932に変換する
  let EV_toFenc_txt = 'cp932'
<
  smoopy >
  " smoopyで開く
  let ExtViewer_txt = '!start "'.'C:/viewer/smoopy.exe'.'"'.' -l%l "%f"'
  "cp932に変換する
  let EV_toFenc_txt = 'cp932'

* Linux

  Evince >
  let ExtViewer_txt = "call system('evince %f &')"
  let EV_toFenc_txt = ''

%f はファイル名、%l がカーソル位置の行番号に置換されますので、起動したい外部ビ
ューアに合わせて変更して下さい。
EV_toFenc_txt が空文字列か、未定義の場合は元ファイルと同じエンコーディングにな
ります。
Linuxの場合は pdf変換して表示するなどの適当なスクリプトを作成して渡してやると
良いかと思います。
設定例のpathは環境に合わせて変更して下さい。

------------------------------------------------------------------------------
使い方
JpExtViewerを実行すると現在開いているバッファの内容をファイルに出力してから外
部ビューアで開きます。 >
  :JpExtViewer

編集内容を保存していなくても反映されます。
また、3:JpExtViewer のようなカウント指定やビジュアルモードでファイルに渡す範囲
指定が可能です。

直接ファイルを渡して実行したい場合は ! を付けて実行します。 >
  :JpExtViewer!

------------------------------------------------------------------------------
その他のオプション
>
  " JpFormatを使用した連結を行う
  let EV_JoinStr = 1
  " 連結マーカーを削除する。
  let EV_RemoveMarker = 1

JpFormat.vimで整形しながら編集しているファイルには連結マーカーや改行が埋め込ま
れています。
デフォルトではファイルの内容を連結してから外部ビューアへ渡しますが、連結が必要
ない場合は EV_JoinStr = 0 を指定してください。
連結は必要ないが、連結マーカーは削除したい場合は追加で EV_RemoveMarker = 1 を
指定します。

外部ビューアに渡すファイル名を固定できます。
EV_Tempname_txtを .vimrcで定義すると指定した名前が使用されます。
'~/.evtemp'のようにディレクトリ指定も可能です。 >
  " 外部ビューアに渡すファイル名
  let EV_Tempname_txt = 'evtemp'

==============================================================================
11. Tips						 *jpformat_tips*

禁則処理は基本的に次のように処理されます。
  1. まず指定文字数に行を分割
  2. 次行の行頭禁則文字(JpKinsoku)を現在行へ移動
  3. 現在行の行末禁則文字(JpKinsokuE)を次行へ移動
  4. ぶら下がり文字数を超えてぶら下がっていたら追い出し(JpKinsokuO)
     (JpKinsokuOが未設定の場合はJpKinsokuで代用されます)

  JpKinsoku, JpKinsokuE, JpKinsokuOは [ と ] でくくった正規表現で指定します。
  実際の設定についてはmisc/kinsoku.vimを参考にしてみてください。

"……" や "っ" などの拗促音は行頭禁則和字ですが、行頭に有ってかまわないものと
して処理されている場合も多いので、ぶら下げないように行頭禁則(JpKinsoku)から外
しても良いかもしれません。

次のように行頭禁則から削除すると、拗音だけではなくや "…" 、 "―" もぶら下げな
いようになります。
>
  let JpKinsoku = '[-!?}>－ｰ～！？゛゜ゝゞ）］｡｣､･ﾞﾟヽヾー々‐・:;.°′″、。，．,)\]｝〕〉》」』】〟’”≫]'

ただし "…" を行頭禁則から削除すると …… 等の分離不可文字でも分割されてしまう
ので追い出し処理を行うように設定可能です。
>
  " ぶら下がり文字数を超えている時、JpKinsokuO以外の1文字を足して追い出す。
  " 未設定時にはJpKinsokuで代用される。
  let JpKinsokuO = '[-!?}>－ｰ～！？゛゜ゝゞ）］｡｣､･ﾞﾟヽヾー々‐・:;.°′″、。，．,)\]｝〕〉》」』】〟’”≫―…‥]'

実際問題としては "…" 等を行頭禁則として扱わない場合、分離不可としても扱わない
ことが多いようなので、JpKinsokuOを設定する必要はないかもしれません。

------------------------------------------------------------------------------
markdownでは改行が「行末の半角スペース２文字以上」ですが、連結マーカーをこれに
合わせると便利かもしれません。
>
  " 連結マーカー
  let JpFormatMarker = "  "

------------------------------------------------------------------------------
JpFormat.vimを使用している場合、連結マーカーに対応させるため J や Ctrl-V など
一部のコマンドをオーバーライドしています。
何か問題があって擬似ソフトラップを使用しているバッファでのみオーバーライドさせ
たい場合は以下を.vimrcに追加してください。
>
  " J や <C-v>をバッファローカルにオーバーライド
  let JpFormatBufLocalKey = 1
>
ただしこの場合はJpFormat.vimのコマンドを実行しないかぎり、コマンドのオーバーラ
イドを行いません。
このためバッファを開いて最初にJコマンドを実行する場合、連結マーカー対応の連結
を行わないことがあります。(JpSetAutoFormatを実行している場合は問題ありません)
必要なら先になにかコマンドを実行するか、JpFormatBufLocalKeyを実行してください。
>
  :JpFormatBufLocalKey

------------------------------------------------------------------------------
主に日本語入力を行うような場合、カーソルを画面中央に固定する「タイプライタース
クロール」という機能を持つエディタがあります。
Vimでもほぼ同等の設定が行なえます。
>
  " タイプライタースクロール
  set scrolloff=999

設定値が画面表示行数の1/2以上であればカーソルが画面中央に固定されます。
カーソル位置からの表示行数が画面の表示行数より多くないと効果はありません

scrolloffの設定はグローバルですが、特定のバッファのみJpFormatを利用した簡易的
な「タイプライタースクロール」を使用することもできます。
JpFormatの「タイプライタースクロール」を使用したいバッファで、次のバッファロー
カル変数を設定してください。
>
  :let b:typewriterscroll=1

有効にすると、挿入モード移行時にカーソル位置が画面中央に設定されます。
なお「自動整形」|jpformat_auto_format|が有効でないと入力中にはカーソル位置の調
整は行われません。

==============================================================================
12. オプションリスト					 *jpformat_option_list*

禁則文字列を独自に設定したい場合は misc/kinsoku.vimをruntimepathの通った場所か
JpFormat.vimと同じ場所へコピーして改変すると楽です。
Windowsで内部エンコーディングがcp932の場合はmisc/kinsoku-cp932.vimを使用してく
ださい。
 >
  " 文字数指定を半角/全角単位にする
  " 1:半角
  " 2:全角
  let JpFormatCountMode = 2
  " 原稿(折り返し)全角文字数
  let JpCountChars = 40

  " 原稿行数
  let JpCountLines = 17

  " 禁則処理の最大ぶら下がり字数
  let JpCountOverChars = 1

  " 禁則処理の最大追い出し字数
  let JpCountOutChars = 4

  " 半角一文字分オーバーしても折り返し処理をする/しない
  let JpFormatHankakuOver = 0

  " 折り返し文字数(原稿用紙文字数)は textwidthから設定する
  let JpCountChars_Use_textwidth = 0

  " 挿入モードで一文字入力する度に自動整形を行う/行わない
  let JpFormatCursorMovedI = 0

  " 挿入モードへ移行したら自動連結
  " (JpFormatCursorMovedI=0の時のみ有効)
  "  1 : カーソル位置以降を自動連結
  "  2 : パラグラフを自動連結
  let JpAutoJoin = 1

  " 整形対象外行の正規表現
  let JpFormatExclude = '^$'

  " 原稿用紙換算計算時に削除するルビ等の正規表現
  let JpCountDeleteReg = '\[[^]]\+\]\|<[^>]\+>\|《[^》]\+》\|［[^］]\+］\|｜'

  " 整形コマンドを使用したら自動整形もON
  let JpAutoFormat = 1

  " 連結マーカー
  let JpFormatMarker = "\t"

  "  基本的な処理方法
  "  1. まず指定文字数に行を分割
  "  2. 次行の行頭禁則文字(JpKinsoku)を現在行へ移動
  "  3. 現在行の行末禁則文字(JpKinsokuE)を次行へ移動
  "  4. ぶら下がり文字数を超えてぶら下がっていたら追い出し(JpKinsokuO)
        (JpKinsokuOが未設定の場合はJpKinsokuで代用されます)

  " 行頭禁則
  let JpKinsoku = '[-}>）―～－ｰ］！？゛゜ゝゞ｡｣､･ﾞﾟ,)\]｝、〕〉》」』】〟’”ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎ々‐?!・:;。.…‥]'
  " 行末禁則
  let JpKinsokuE = '[-0-9a-zA-Z([{<（｛〔〈《「『【〝‘“≪]'
  " 句点と閉じ括弧
  let JpKutenParen = '[、。，．,)\]｝〕〉》」』】〟’”≫]'
  " 句点と閉じ括弧で分離不可文字追い出し用
  " 分離不可文字を追い出す時JpNoDivNがあったら、そこから追い出し。
  " ですか？――<分割> があったら ？は残して――のみを追い出すための指定。
  let JpNoDivN = '[、。，．,)\]｝〕〉》」』】〟’”≫!?！？]'
  " 分離不可
  let JpNoDiv = '[―…‥]'
  " 追い出し用
  " ぶら下がり文字数を超えている時、JpKinsokuO以外の1文字を足して追い出す。
  " 未設定時にはJpKinsokuで代用される。
  " let JpKinsokuO = '[-}>）―～－ｰ］！？゛゜ゝゞ｡｣､･ﾞﾟ,)\]｝、〕〉》」』】〟’”ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎ々‐?!・:;。.…‥]'

  " 連結マーカー非使用時のTOLキャラクター
  let JpJoinTOL = '[\s　「・＊]'
  " 連結マーカー非使用時のEOLキャラクター
  let JpJoinEOL = '[。」！？］]'

  " Jや<C-v>の置き換えをバッファローカルで行う
  let JpFormatBufLocalKey = 0

  vim:tw=78:ts=8:ft=help:norl

