*jpformat.jax*	For Vim バージョン 7.2	Last change: 2011 December 29
==============================================================================
       Description: JpFormat.vim 日本語整形プラグイン
            Author: fuenor <fuenor@gmail.com>
            Web(Japanese):
            http://sites.google.com/site/fudist/Home/jpformat
            https://github.com/fuenor/JpFormat.vim
==============================================================================

CONTENTS					*jpformat_contents*
1. Intro                                        |jpformat_intro|
2. インストール                                 |jpformat_install|
  2.1 gqコマンドとして使用する場合の設定        |jpformat_install_gq|
3. コマンド一覧                                 |jpformat_command|
4. 手動整形                                     |jpformat_format|
5. 自動整形                                     |jpformat_auto_format|
6. 整形行の連結                                 |jpformat_join|
7. 原稿枚数を計算する。                         |jpformat_count|
8. オプション                                   |jpformat_options|
9. 整形の内部処理                               |jpformat_formatexpr|
10. 外部ビューアを起動する                      |jpformat_viewer|
11. Tips                                        |jpformat_tips|
12. オプションリスト                            |jpformat_option_list|

==============================================================================
1. Intro						*jpformat_intro*

JpFormat.vimはVimで日本語の禁則処理に対応したフォーマット整形プラグインです。

formatexprに登録して日本語対応のgqコマンドとして使うことも可能ですが、本プラグ
インは入力を行いながら編集中の日本語文書を自動整形して原稿の整形結果を常に確認
しながら編集を行うことを主な目的にしています。

Vim単体でも|wrapmargin|や|textwidth|などを使用して整形が行えますが日本語の禁則
処理は考慮されていませんし、gqコマンドは空行のみを段落の区切りとみなして連結し
て改行を埋め込んでしまうので本来の構造が失われます。
JpFormat.vimでは空白行ではなく改行を段落として扱うので改行に意味のある文書でも
きちんと整形できます。

JpFormat.vimの大きな特徴は疑似ソフトラップが行える事です。
実際に折り返しを行う際には改行を埋め込みますが、表示上の改行をマーカーで管理す
るので原稿形式を何回変更しても元の構造は保持され、何度整形しても元の非整形状態
に戻せるために安心して書きかけの原稿に整形を掛ける事が出来ます。
このため未完成原稿でも整形結果を確認しながら、挿入モードで入力する度に自動整形
するような使い方もストレス無く実行出来ます。
未完成原稿ではマーカーを使用して整形し、最終原稿では全文連結コマンドかマーカー
削除を実行するというのが主な使い方になります。

Vimでのメールの下書きや、青空文庫の小説などの長文を読むような場合は折り返し整
形してやると読みやすさが結構違ってきます。

このファイルもJpFormat.vimを使用して整形されています。

==============================================================================
2. インストール						*jpformat_install*

jpformat.zipまたはGitHub(https://github.com/fuenor/JpFormat.vim)からダウンロー
ドしたzipファイルを解凍してできたディレクトリにランタイムパスを通します。

    1. jpformat.zipを解凍します。
    2. jpfmt というディレクトリが作成されます。
      (GitHubからダウンロードした場合は解凍してできたディレクトリ名に読み替え
      てください)
    3. jpfmt を適当な場所にコピーして、ランタイムパスを通します。

c:\tempにjpfmtをコピーした場合は、_vimrc(Linuxは .vimrc) で次のようにパスを通
します。
>
  set runtimepath+=c:/temp/jpfmt

2.1 gqコマンドとして使用する場合の設定 			*jpformat_install_gq*

JpFormat.vimにはgqコマンドとして使用可能な、日本語禁則処理対応の整形プラグイン
jpfmt.vimとjpvim.vimが同梱されています。
jpfmt.vimをgqコマンドとして使用する場合はformatexprを設定してください。 >

  " 日本語対応gqコマンドとして使用する
  set formatexpr=jpfmt#formatexpr()

単にgqコマンドとしてのみ使用する場合はこれだけで動作しますので、日本語の長い行
で gqq などとして実行してみてください。

jpvim.vimはjpfmt.vimと違い、設定にかかわらず「ぶら下げ」を行いません。
gqコマンドとしてはjpvim.vimのほうが違和感がないかもしれません。
>
  " ぶら下げを行わない日本語対応gqコマンドとして使用する
  set formatexpr=jpvim#formatexpr()

また日本語文書への対応として行頭が 　 (全角スペース)か「 で始まった場合は段落
開始とみなして処理を行います。
(このためgq8jのように複数行をまとめて処理しても「で始まる行は連結されません)
ユーザー指定の段落開始行は jpfmt_paragraph_regexp の正規表現で指定可能です。
>
  " 段落開始とみなす正規表現
  let jpfmt_paragraph_regexp = '^[　「]'

次章からは主に連結マーカーを利用した擬似ソフトラップを行うためのコマンド群につ
いての解説になります。
単にgqコマンドとしてしか使用しないけれども、禁則処理対象文字を変更したいなどの
場合は|jpformat_tips|, |jpformat_option_list|を参照してみてください。

==============================================================================
3. コマンド一覧						*jpformat_command*

いずれのコマンドもビジュアルモードやカウントで範囲を指定できます。

JpFormat           指定範囲を整形する。
		   !を付けると整形対象外の行でも強制整形する。
JpFormatAll        指定範囲(デフォルトは全て)を整形する。
		   !を付けると連結マーカーを使用しない。
JpFormatP          指定範囲を含むパラグラフを整形する。
		   !を付けると整形対象外の行でも強制整形する。

JpJoin             指定範囲を含むパラグラフを連結する。
JpJoinAll          指定範囲(デフォルトは全て)を含むパラグラフを連結する。
		   !をつけると連結マーカーを使用していないものとして連結する。
JpYank             現在行を含むパラグラフをヤンクする

JpFormatToggle     自動整形の有効/無効を切り替える。
		   30:JpFormatToggleのようにカウント指定すると折り返し文字数が
		   現バッファのみ指定カウントに変更される。
		   例えば gC など適当なキーにマップして gC や 30gCとして使う。
JpFormatGqToggle   整形に gqコマンドを呼び出して行うかどうかを切り替える。

JpCountPages       指定範囲(デフォルトは全て)のルビ等を削除した原稿枚数を計算
		   する。
		   !を付けると整形結果に置き換える。
JpExtViewer        現バッファの内容をコピーして、連結、エンコードの変換を行
		   ってから外部ビューアを起動する。
		   !を付けると現在開いているファイルそのものを渡して起動する。

・ここで言う連結とはJpFormat.vimで整形された分割部分を元に戻す事です。
・整形されていない行では連結を実行しても何もしないので、単純な連結には通常の行
と同じく J を使用して下さい。
・パラグラフとは物理的な改行で区切られた1行を整形分割した全ての行のまとまりで
す。

==============================================================================
4. 手動整形						*jpformat_format*

:JpFormatAll を実行すると指定範囲(デフォルトは全て)を規定の形式に整形します。
何か一行が長い日本語文書を用意して実行してみて下さい。
小説が一番わかりやすいので、適当なファイルがなければ青空文庫などから持ってくる
のも良いかもしれません。 >
  :JpFormatAll

整形結果を見るとわかりますが、長い文は「タブ記号+改行」で分割して禁則処理を行
います。
このタブ記号は「連結マーカー」で、改行が実際の改行なのか、整形によって分割され
た改行なのかを示しています。
:JpJoinAll を実行すると分割行は連結されます。

NOTE:デフォルトの「連結マーカー」にはタブ記号が使われていますが、何も設定しな
いと見えません。
タブ記号は .vimrc に以下の設定を行うと|SpecialKey|で強調表示されます。 >
  set list
  set listchars=tab:^\ ,trail:~

ノーマルモードで現在行を手動整形したい場合はJpFormatコマンドを使用するか、キー
にマッピングして使用して下さい。JpFormatやJpFormatAll はカウント指定やビジュア
ルモードの指定も有効です。

------------------------------------------------------------------------------
.vimrc でのキーマップ設定例
>
  " 日本語の行の連結時には空白を入力しない。
  set formatoptions+=mM

  " 現在行を整形
  noremap <silent> gl :JpFormat<CR>
  " 現在行が整形対象外でも強制的に整形
  noremap <silent> gL :JpFormat!<CR>

  " 自動整形のON/OFF切替
  " 30gC の様にカウント指定すると、
  " 現バッファのみ折り返し文字数を指定されたカウントに変更
  nnoremap <silent> gC :JpFormatToggle<CR>

  " カーソル位置の分割行をまとめてヤンク
  noremap <silent> gY :JpYank<CR>
  " カーソル位置の分割行をまとめて連結
  noremap <silent> gJ :JpJoin<CR>

  " 外部ビューアを起動する
  nnoremap <silent> <F8> :JpExtViewer<CR>

この例だと gl で整形することになります。
コマンドは 3gl の用にカウント指定や、ビジュアルモードで範囲を指定可能です。
単純な連結は通常通り J で、分割された行(パラグラフ)は gJ でまとめて連結可能で
す。
実際には JpFormat と JpFormatToggle、JpJoinAll をマップすれば十分使えます。

------------------------------------------------------------------------------
非整形状態に戻すには :JpJoinAll を実行しますが、整形状態を保ったまま連結マー
カーを削除したい場合は :JpFormatAll! を実行して下さい。
JpFormatAll!で「連結マーカー」を削除する場合は不可逆過程ですので、必ずバックア
ップを取ってから実行して下さい。

formatoption は好みですが、J コマンドでの日本語を含む行の連結は空白を追加しな
い方がよいかと思います。

==============================================================================
5. 自動整形						*jpformat_auto_format*

基本的には JpFormat と JpJoin を好みのキーにマッピングして、必要に応じて整形、
連結を行います。
ただ一々手動で整形するのも面倒なので、自動整形させる事が可能です。

何か一行が長い文を含む日本語文書のファイルを用意して :JpFormatAll や :JpFormat
コマンドで整形するか、キーマップした整形コマンドを実行して下さい。
長い行は整形され、そのあと挿入モードで適当に入力すると自動で整形が行われます。

* 自動整形の種類

自動整形は挿入モードで一文字入力する度に自動整形をするか、挿入モード終了時に自
動整形するかを選択できます。 >
  " 挿入モードでキー入力する度に自動整形を行う/行わない
  let JpFormatCursorMovedI = 1

JpFormatCursorMovedI = 1 に設定すると挿入モードで一文字入力する度に自動整形さ
れ JpFormatCursorMovedI = 0 なら挿入モードを抜ける時にまとめて整形を行います。
編集時の見やすさなども含めて好みの方を使用して下さい。

自動整形が有効になるのは以下の場合です。

    * バッファ内でJpFormat等のコマンドを実行した後
    * バッファローカルな変数 b:jpformat を 1 に設定した時
    * 特定の拡張子のファイルで整形済みの行があるファイルを開く場合

以下を .vimrcに追加すると、次回からはtxtファイルに「連結マーカー+改行」があれ
ば自動整形モードが最初から有効になります。 >
  " txtファイルで「連結マーカー+改行」が有ったら自動整形を有効にする
  au BufRead *.txt  silent! call JpSetAutoFormat()

自動整形自体は :JpFormatToggleを実行してON/OFF切替可能ですが、バッファローカル
なオプション b:jpformat = 0 に設定してもそのバッファのみ自動整形はオフになりま
す。

==============================================================================
6. 整形行の連結						*jpformat_join*

単に非整形状態に戻したいだけの場合は JpJoinAll を実行します。 >
  :JpJoinAll

整形状態を保ったまま「連結マーカー」を削除したい場合、「連結マーカー」を使用し
ないで全文整形(コマンドに ! を付加して実行)します。 >
  :JpFormatAll!

「連結マーカー」はただの文字(タブ記号)なので通常の削除や置換でも削除可能です。 >
  :%s/\t$//g

再連結は JpJoinAll! です。

「連結マーカー」が削除されていても再連結は可能ですが、整形前の文書と異なる場合
があります。
これは整形表示行の境界や「ぶら下げ」処理された次の行が、真の改行か整形されたこ
とによる改行かの区別がつかない場合があるためです。
「連結マーカー」の削除は不可逆過程ですので最終処理としてバックアップを取った上
で実行して下さい。

「連結マーカー」を使用しない連結の行判定には以下のオプションが使用されます。 >
  " 連結マーカー非使用時のTOLキャラクター
  let JpJoinTOL = '[\s　「・＊]'
  " 連結マーカー非使用時のEOLキャラクター
  let JpJoinEOL = '[。」！？］]'

==============================================================================
7. 原稿枚数を計算する。					 *jpformat_count*

:JpCountPages を実行すると現在の原稿枚数を計算できます。 >
 :JpCountPages

計算する際にはルビや制御用スクリプトを削除した、実際の原稿枚数を計算します。
>
  " 原稿用紙換算計算時に削除するルビ等の正規表現
  let JpCountDeleteReg = '\[[^]]\+\]\|<[^>]\+>\|《[^》]\+》\|［[^］]\+］\|｜'

現在の縦文字数や行数と異なるページ数をカウントしたい場合は、JpCountPages実行時
に文字数と行数を指定します。
>
  JpCountPages [折り返し文字数] [行数] {ぶら下がり文字数}
<
  行数、ぶら下がり文字数は省略可能です。

現在40×17フォーマットで整形していて、20×20フォーマットのページ数を知りたい場
合は次のように実行します。 >
  :JpCountPages 20 20

------------------------------------------------------------------------------
* 原稿枚数計算のEasyモード

原稿枚数計算では内部的に全文整形を行っているので、長い文書ではそれなりに時間が
かかります。
概算でかまわないような場合、整形済みの文書では簡易的に行数から原稿枚数計算を行
う事が出来ます。
>
  :JpCountPages!

Easyモードではルビ等も通常の文字と見なされますが、ルビ等の制御記号を使用してい
なければ正確な枚数表示がなされます。 >
文書内に連結マーカーが存在しない場合は通常通り JpCountPagesが実行されます。

JpCountPagesは適当なキーにマップして使用すると良いかもしれません。
>
  " 現在の原稿枚数計算(簡易)
  noremap <silent> gc :JpCountPages!<CR>

------------------------------------------------------------------------------
* リアルタイムに文字数を確認する

JpFormat.vimとは直接関係ありませんが、ステータス行に現バッファの文字数を表示す
ることも出来ます。
https://github.com/fuenor/vim-wordcount/blob/master/wordcount.vim

==============================================================================
8. オプション						*jpformat_options*

* 原稿形式(折り返し文字数等)

原稿形式は以下のオプションで設定します。 >

 " 原稿文字数(全角の折り返し文字数)
 let JpCountChars = 40
 " 原稿行数
 let JpCountLines = 17
 " 禁則処理の最大ぶら下がり字数(-1なら全てぶら下げ)
 let JpCountOverChars = 1

このオプション値はデフォルト指定で、実際に整形する時は b: のついたバッファロー
カルな変数が使用されます。

特定のバッファでデフォルト以外の値を使用したい場合は b: を付けて指定します。
たとえば一行あたりの文字数を変更したい場合は、コマンドモードから次のように指定
します。 >
  :let b:JpCountChars=30

また通常 :JpFormatToggleは自動整形のON/OFFを切り替えるために使用しますが、カウ
ント指定した場合はON/OFF切り替えではなく指定カウントをそのバッファの折り返し文
字数に設定します。
>
  :30JpFormatToggle
<
  これは :let b:JpCountChars=30と同等の結果になります。
  JpFormatToggleをキーマップしておいて使用すると便利かもしれません。

特定拡張子や特定ファイルで個別の文字数で折り返したい時は.vimrcで次のように設定します。 >
  " 拡張子howmの折り返し文字数は30文字
  au BufRead,BufNewFile *.howm  let b:JpCountChars=30
  " 拡張子txtの折り返し文字数は20文字
  au BufRead,BufNewFile *.txt   let b:JpCountChars=20
  " abc.txtの折り返し文字数は42文字
  au BufRead,BufNewFile abc.txt let b:JpCountChars=42

textwidthから折り返し文字数を設定する事も出来ます。 >
  "折り返し文字数は textwidthから設定する
  let JpCountChars_Use_textwidth = 1
<
  1に設定すると b:JpCountCharsは textwidthの値(全角換算なので textwidth/2)を使
  用します。

現在の縦文字数や行数と異なる形式へ一時的に整形したい場合は、実行時に指定します。
  JpFormatAll [折り返し文字数] [行数] {ぶら下がり文字数}

行数やぶら下がり文字数は省略可能です。
現在40×17フォーマットで整形していて、20×20フォーマットに変更したい場合は次の
ように実行します。 >
  :JpFormatAll 20 20

------------------------------------------------------------------------------
* 特定の行を整形対象外にする

特定の行を整形対象外にする事も出来ます。
整形対象外にする条件は JpFormatExcludeで指定します。
このオプションはデフォルト指定で、実際に整形する時はバッファローカルな変数
b:JpFormatExclude が使用されます。
デフォルトでは空文字列(実際には'^$'に変換されます)が指定されているので全ての行
が対象です。

以下のように設定すると半角文字だけの行なら整形しません。 >
  " 整形対象外の正規表現(空文字 か'^$' を指定すると全ての行が整形対象)
  " 半角だけの行は整形しない
  let JpFormatExclude = '^[^[[:print:][:space:]]\+$'

行頭が日本語以外は対象外にしたい場合は以下のようにします。 >
  " 日本語以外で始まった場合は整形しない
  let JpFormatExclude = '^[[:print:][:space:]]'

gqなどの整形コマンドや他の整形プラグインを併用したい場合、使用したい行を対象外
に設定して使用してください。

特定のファイルでだけ整形対象外の正規表現を変更することも出来ます。
b:を付けて .vimrcで指定して下さい。 >
  au BufRead,BufNewFile *.howm let b:JpFormatExclude = '^[-+.*=|>";/[[:space:]]'

==============================================================================
9. 整形の内部処理					*jpformat_formatexpr*

JpFormat.vimの整形処理はJpFormat.vimの「内部整形」と「|gq|」による外部コマンド
整形との2種類から選択可能です。

内部整形はインデントやコメントの処理は行わず英数字の処理はVimデフォルトのgqコ
マンドとは異なる処理になりますが非常に高速です。
内部整形は基本的に日本語文書専用ということになります。 >

外部コマンド整形は|formatexpr|に登録可能であれば使用可能です。 >
行頭の空白やタブも認識しインデントして整形されますが、日本語の禁則処理等はgqに
登録するコマンドに依存することになります。 >

JpFormat.vimで使用する整形コマンドと|formatexpr|に登録するコマンドを個別に設定
したい場合はJpFormat_formatexprを設定します。 >
  " jpfmt.vimをJpFormat.vimの整形コマンドとして使用する
  let JpFormat_formatexpr = 'jpfmt#formatexpr()'

NOTE:
内部整形とgq整形は :JpFormatGqToggle でも切り替える事が出来ます。

------------------------------------------------------------------------------

実際問題としてVimデフォルトの|gq|は日本語の禁則処理に対応していませんので日本語
に対応したgqコマンドを用意する必要があります。
現在のところはjpfmt.vimとautofmt.vimで動作を確認しています。
(jpfmt.vimはJpFormat.vimに同梱されています)

環境や設定によるのであくまで参考程度ですが、速度的には同じ日本語文書(200kb)の
全文一括整形で次の表のような速度差があります。

 * 約200kbの日本語文書を全文整形した場合の所要時間
 内部整形(JpFormat)         5   sec
 jpfmt.vim(JpFormat同梱)    35  sec    jpfmt#formatexpr()
 autofmt.vim                147 sec    autofmt#Japanese#formatexpr()

jpfmt.vimはJpFormat.vimの日本語処理部分にインデント処理を追加したgqスクリプト
で、日本語部分はJpFormat.vimと同じ処理が行われます。

「内部整形」は日本語の処理を主な目的にしているために、英数字の扱いがVim標準の
gqコマンドと異なる処理を行います。
気になる場合は :JpFormatGqToggleを適当なキーにマップして、「内部整形」と「gq」
を切り替えて使うとよいかもしれません。

------------------------------------------------------------------------------
* 内部整形(JpFormat.vim)

formatexprは使用せずにビルトインの禁則処理関数で整形していて高速に動作します。
なお英数字で分割される場合はgq(Vim)と異なる処理が行われます。 >
  " 内部整形で整形を行う(デフォルト)
  let JpFormatGqMode = 0

------------------------------------------------------------------------------
* gq(Vim)

Vimの|formatexpr|に登録されているgqコマンドを利用して整形する場合は次のように
設定します。 >
  " gqを使用して整形を行う
  let JpFormatGqMode = 1

明示的にVimデフォルトのgqを設定したい場合は次のようになります。 >
  " gqを使用して整形を行う
  let JpFormatGqMode = 1
  " Vimのデフォルトgqコマンドを使用する
  let JpFormat_formatexpr = 'jpcpt#formatexpr()'

NOTE:Vimのデフォルトで使用されるgqコマンドは日本語に対応していないので、この場
合は日本語の禁則処理は行われません。
日本語の禁則処理を行うためには日本語対応のgqコマンドを入手する必要があります。
(日本語対応のgqコマンドとしては jpfmt.vimが同梱されています)

------------------------------------------------------------------------------
* jpfmt.vim

速度的には内部整形(JpFormat.vim)より遅くなりますが、整形時に英数字で分割される
場合はgq(Vim)とコンパチブルな処理を行います。 >
  " gqを使用して整形を行う
  let JpFormatGqMode = 1
  " jpfmt.vimをJpFormat.vimの整形コマンドとして使用する
  let JpFormat_formatexpr = 'jpfmt#formatexpr()'

整形オプションには JpFormat.vimのオプションが使用されます。

日本語文書への対応として行頭の 　 (全角スペース)か 「 で始まった場合は段落開始
とみなして処理を行います。
ユーザー指定の段落開始行は jpfmt_paragraph_regexp の正規表現で指定可能です。
不要な場合は '' を指定してください。
>
  " 段落開始とみなす正規表現
  let jpfmt_paragraph_regexp = '^[　「]'

jpfmt#formatexpr()の動作は JpFormat.vimの設定に依存し、「ぶら下げ」処理も行い
ますが、「ぶら下げ」処理が不要な場合は jpvim#formatexpr()を使用してください。
>
  " 「ぶら下げ」を行わないjpvim.vimをJpFormat.vimの整形コマンドとして使用する
  let JpFormat_formatexpr = 'jpvim#formatexpr()'

------------------------------------------------------------------------------
* autofmt.vim

UAX#14準拠の日本語整形処理を行えますが、速度は非常に遅くなります。
技術文書や比較的短文しか扱わないならautofmt.vimでも良いかもしれません。 >
  " gqコマンドを使用して整形を行う
  let JpFormatGqMode = 1

autofmt.vim
http://www.vim.org/scripts/script.php?script_id=1939

NOTE: autofmt.vimは機能的には問題ないのですが、速度が非常に遅いので全文整形を
行う際は気をつけて下さい。
JpFormatCursorMovedI = 1 で使用すると長い行では文字の取りこぼしも起こり得ま
す。

どうしてもUAX#14の整形処理が必要な場合、編集中は内部整形かjpfmt.vimを使用して
最終処理としてautofmt.vimで整形すると良いかもしれません。

==============================================================================
10. 外部ビューアを起動する				 *jpformat_viewer*

JpFormat.vimで整形しながら編集しているファイルには連結マーカーや改行が埋め込ま
れています。
Vimは縦書き表示できないので青空文庫ビューアを起動して縦書き表示で確認するよう
な場合は、ルビや制御用スクリプトなどで埋め込まれているマーカーや改行が問題にな
ることがあります。
この問題に対応して JpFormat.vimから外部ビューアで開く際に分割行の連結とファイ
ルエンコーディングの変更を行ってから外部ビューアへ渡す事が出来ます。

設定
  必要ならファイルを開くための外部ビューアをインストールしてください。
  例: ArisuViewer, smoopy

* Windows

  ArisuViewer >
  " ArisuViewerで開く
  let ExtViewer_txt = '!start "'.'C:/viewer/ArisuViewer.exe'.'"'.' -l %l "%f"'
  " ArisuViewerはcp932しか扱えないので変換する
  let EV_toFenc_txt = 'cp932'
<
  smoopy >
  " smoopyで開く
  let ExtViewer_txt = '!start "'.'C:/viewer/smoopy.exe'.'"'.' -l%l "%f"'

* Linux

  Evince >
  let ExtViewer_txt = "call system('evince %f &')"
  let EV_toFenc_txt = ''

%f はファイル名、%l がカーソル位置の行番号に置換されますので、起動したい外部ビ
ューアに合わせて変更して下さい。
EV_toFenc_txt が空文字列か、未定義の場合は元ファイルと同じエンコーディングにな
ります。
Linuxの場合は pdf変換して表示するなどの適当なスクリプトを作成して渡してやると
良いかと思います。
設定例のpathは環境に合わせて変更して下さい。

------------------------------------------------------------------------------
使い方
JpExtViewerを実行すると現在開いているバッファの内容をファイルに出力してから外
部ビューアで開きます。 >
  :JpExtViewer

編集内容を保存していなくても反映されます。
また、3:JpExtViewer のようなカウント指定やビジュアルモードでファイルに渡す範囲
指定が可能です。

直接ファイルを渡して実行したい場合は ! を付けて実行します。 >
  :JpExtViewer!

------------------------------------------------------------------------------
その他のオプション
>
  " JpFormatを使用した連結を行う
  let EV_JoinStr = 1
  " 連結マーカーを削除する。
  let EV_RemoveMarker = 1

JpFormat.vimで整形しながら編集しているファイルには連結マーカーや改行が埋め込ま
れています。
デフォルトではファイルの内容を連結してから外部ビューアへ渡しますが、連結が必要
ない場合は EV_JoinStr = 0 を指定してください。
連結は必要ないが、連結マーカーは削除したい場合は追加で EV_RemoveMarker = 1 を
指定します。

外部ビューアに渡すファイル名を固定できます。
EV_Tempname_txtを .vimrcで定義すると指定した名前が使用されます。
'~/.evtemp'のようにディレクトリ指定も可能です。 >
  " 外部ビューアに渡すファイル名
  let EV_Tempname_txt = 'evtemp'

==============================================================================
11. Tips						 *jpformat_tips*

禁則処理は基本的に次のように処理されます。
  1. まず指定文字数に行を分割
  2. 次行の行頭禁則文字(JpKinsoku)を現在行へ移動
  3. 現在行の行末禁則文字(JpKinsokuE)を次行へ移動
  4. ぶら下がり文字数を超えてぶら下がっていたら追い出し(JpKinsokuO)
     (JpKinsokuOが未設定の場合はJpKinsokuで代用されます)

  JpKinsoku, JpKinsokuE, JpKinsokuOは [ と ] でくくった正規表現で指定します。
  実際の設定についてはmisc/kinsoku.vimを参考にしてみてください。

"……" や "っ" などの拗促音は行頭禁則和字ですが、行頭に有ってかまわないものと
して処理されている場合も多いので、ぶら下げないように行頭禁則(JpKinsoku)から外
しても良いかもしれません。

次のように行頭禁則から削除すると、拗音や "…" 、 "―" もぶら下げないようになり
ます。
>
  let JpKinsoku = '[-!?}>－ｰ～！？゛゜ゝゞ）］｡｣､･ﾞﾟヽヾー々‐・:;.°′″、。，．,)\]｝〕〉》」』】〟’”≫]'

ただし "…" を行頭禁則から削除すると …… 等の分離不可文字でも分割されてしまう
ので追い出し処理を行うように設定可能です。
>
  " ぶら下がり文字数を超えている時、JpKinsokuO以外の1文字を足して追い出す。
  " 未設定時にはJpKinsokuで代用される。
  let JpKinsokuO = '[-!?}>－ｰ～！？゛゜ゝゞ）］｡｣､･ﾞﾟヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎ々‐・:;.°′″、。，．,)\]｝〕〉》」』】〟’”≫―…‥]'

実際問題としては "…" 等を行頭禁則として扱わない場合、分離不可としても扱わない
ことが多いようなので、JpKinsokuOを設定する必要はないかもしれません。

------------------------------------------------------------------------------
txtファイルでは「」で囲まれた部分を強調表示するように設定するような場合、分割
されて改行が挿入されても強調表示が行われるように region を使用すると良いかもし
れません。 >

  "「」強調
  syntax region txtDialog matchgroup=Normal start=+「+ end=+」+ contains=txtDialog
  hi link txtDialog Special

==============================================================================
12. オプションリスト					 *jpformat_option_list*

禁則文字列を独自に設定したい場合は misc/kinsoku.vimをruntimepathの通った場所か
JpFormat.vimと同じ場所へコピーして改変すると楽です。

 >
  " 文字数指定を半角/全角単位にする
  " 1:半角
  " 2:全角
  let JpFormatCountMode = 2
  " 原稿(折り返し)全角文字数
  let JpCountChars = 40

  " 原稿行数
  let JpCountLines = 17

  " 禁則処理の最大ぶら下がり字数
  let JpCountOverChars = 1

  " 半角一文字分オーバーしても折り返し処理をする/しない
  let JpFormatHankakuOver = 0

  " 折り返し文字数(原稿用紙文字数)は textwidthから設定する
  let JpCountChars_Use_textwidth = 0

  " 挿入モードで一文字入力する度に自動整形を行う/行わない
  let JpFormatCursorMovedI = 0

  " 整形対象外行の正規表現
  let JpFormatExclude = '^$'

  " 原稿用紙換算計算時に削除するルビ等の正規表現
  let JpCountDeleteReg = '\[[^]]\+\]\|<[^>]\+>\|《[^》]\+》\|［[^］]\+］\|｜'

  " 整形コマンドを使用したら自動整形もON
  let JpAutoFormat = 1

  " 連結マーカー
  let JpFormatMarker = "\t"

  "  基本的な処理方法
  "  1. まず指定文字数に行を分割
  "  2. 次行の行頭禁則文字(JpKinsoku)を現在行へ移動
  "  3. 現在行の行末禁則文字(JpKinsokuE)を次行へ移動
  "  4. ぶら下がり文字数を超えてぶら下がっていたら追い出し(JpKinsokuO)
        (JpKinsokuOが未設定の場合はJpKinsokuで代用されます)

  " 行頭禁則
  let JpKinsoku = '[-!?}>－ｰ～！？゛゜ゝゞ）］｡｣､･ﾞﾟヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎ々‐・:;.°′″、。，．,)\]｝〕〉》」』】〟’”≫―…‥]'
  " 行末禁則
  let JpKinsokuE = '[-0-9a-zA-Z([{<（｛〔〈《「『【〝‘“≪]'
  " 句点と閉じ括弧
  let JpKutenParen = '[、。，．,)\]｝〕〉》」』】〟’”≫]'
  " 句点と閉じ括弧で分離不可文字追い出し用
  " 分離不可文字を追い出す時JpNoDivNがあったら、そこから追い出し。
  " ですか？――<分割> があったら ？は残して――のみを追い出すための指定。
  let JpNoDivN = '[、。，．,)\]｝〕〉》」』】〟’”≫!?！？]'
  " 分離不可
  let JpNoDiv = '[―…‥]'
  " 分離不可(ペア)
  let JpNoDivPair .= '〳〴〵'
  " 追い出し用
  " ぶら下がり文字数を超えている時、JpKinsokuO以外の1文字を足して追い出す。
  " 未設定時にはJpKinsokuで代用される。
  let JpKinsokuO = '[-!?}>－ｰ～！？゛゜ゝゞ）］｡｣､･ﾞﾟヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎ々‐・:;.°′″、。，．,)\]｝〕〉》」』】〟’”≫―…‥]'

  " 連結マーカー非使用時のTOLキャラクター
  let JpJoinTOL = '[\s　「・＊]'
  " 連結マーカー非使用時のEOLキャラクター
  let JpJoinEOL = '[。」！？］]'

  " 挿入モードへ移行したら自動連結
  " 0 : なにもしない
  " 1 : カーソル位置以降を自動連結
  " 2 : パラグラフを自動連結
  let JpAutoJoin = 1
<
  vim:tw=78:ts=8:ft=help:norl

